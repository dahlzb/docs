import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as d,o as l,c as t,a,d as e,b as r,e as s}from"./app-BX-M_jOY.js";const c={},o=s(`<h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h2><h3 id="文件结构" tabindex="-1"><a class="header-anchor" href="#文件结构"><span>文件结构</span></a></h3><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>redis-server        redis服务器
redis-cli           redis命令行客户端
redis-benchmark     redis性能测试工具
redis-check-aof     aof文件修复工具
redis-check-dump    rdb文件检查工具
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令"><span>常用命令</span></a></h3><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 使用默认配置启动redis服务器</span>
redis-server
<span class="token comment"># 使用指定配置文件启动redis服务器</span>
redis-server ./redis.conf
<span class="token comment"># 不指定ip和端口默认连接127.0.0.1:6379</span>
redis-cli
redis-cli <span class="token parameter variable">-h</span> <span class="token number">127.0</span>.0.1 <span class="token parameter variable">-p</span> <span class="token number">6379</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="数据持久化" tabindex="-1"><a class="header-anchor" href="#数据持久化"><span>数据持久化</span></a></h3><h4 id="数据备份" tabindex="-1"><a class="header-anchor" href="#数据备份"><span>数据备份</span></a></h4><p>TODO</p><h4 id="数据迁移" tabindex="-1"><a class="header-anchor" href="#数据迁移"><span>数据迁移</span></a></h4><h5 id="aof方式" tabindex="-1"><a class="header-anchor" href="#aof方式"><span>AOF方式</span></a></h5><p>AOF方式依赖于AOF文件，AOF文件记录了所有写命令。</p><ul><li><p>将源服务器中的AOF文件复制到目标服务器</p></li><li><p>目标服务器开启AOF功能</p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>config <span class="token builtin class-name">set</span> appendonly <span class="token function">yes</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>将源服务器AOF文件数据导入目标服务器</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>redis-cli <span class="token parameter variable">--pipe</span> <span class="token operator">&lt;</span> appendonly.aof
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="rdb方式" tabindex="-1"><a class="header-anchor" href="#rdb方式"><span>RDB方式</span></a></h5><p>使用 Redis 命令创建当前数据库备份，将在安装目录中创建 <code>dump.rdb</code> 文件。</p><p>创建 redis 备份文件也可以使用命令 <code>BGSAVE</code>，该命令在后台执行。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>SAVE 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>关闭目标服务器 redis 服务，关闭目标服务器 AOF 持久化。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>appendonly no
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将源服务器数据库备份文件复制到目标服务器，并替换目标目标服务器的 <code>dump.rdb</code> 文件。</p><p>重启 Redis 服务，使用 <code>redis-cli</code> 执行命令 <code>bgrewriteaof</code> 生成 AOF 持久化文件，修改配置文件开启AOF持久化，重启Redis服务。</p><h3 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制"><span>主从复制</span></a></h3><p>指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower) ; 数据的复制是单向的，只能由主节点到从节点。<code>Master</code> 以写为主，<code>Slave</code> 以读为主。</p><ul><li><p>为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服务器上，连接在一起，并保证数据是同步的。</p></li><li><p>即使有其中一台服务器宕机，其他服务器依然可以继续提供服务，实现Redis的高可用，同时实现数据冗余备份。</p></li><li><p>主从复制即将master中的数据即时、有效的复制到slave中</p></li><li><p>一个master可以拥有多个slave，一个slave只对应一个master</p></li></ul><h4 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h4><ol><li>读写分离：主节点写，从节点读，提高服务器的读写负载能力</li><li>数据冗余︰主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复︰当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 ; 实际上是一种服务的冗余。</li><li>负载均衡︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载 ; 尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用（集群）基石︰除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ol><blockquote><p>Redis 5.0之后，<code>replicaof</code> 已经替换 <code>slaveof</code>，由于一些种族歧视的奇葩要求，Redis已经对指令进行了兼容升级，目前 <code>slaveof</code> 还是可以使用的。</p></blockquote><h4 id="配置" tabindex="-1"><a class="header-anchor" href="#配置"><span>配置</span></a></h4><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 查询主从复制配置</span>
INFO replication
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="修改-redis-conf" tabindex="-1"><a class="header-anchor" href="#修改-redis-conf"><span>修改 redis.conf</span></a></h5><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 修改从库配置文件，设置主库地址</span>
replicaof <span class="token number">192.168</span>.208.128 <span class="token number">6379</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="redis-cli" tabindex="-1"><a class="header-anchor" href="#redis-cli"><span>redis-cli</span></a></h5><p>登录从库，执行以下命令，该方式服务重启后失效</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 设置主库地址</span>
REPLCONF <span class="token number">192.168</span>.208.128 <span class="token number">6379</span>
<span class="token comment"># 取消主从配置</span>
REPLCONF no one
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="哨兵机制" tabindex="-1"><a class="header-anchor" href="#哨兵机制"><span>哨兵机制</span></a></h3><p><code>Redis</code> 的主从复制，在一定程度上保证了数据的可用性，但是如果主从复制中的 <code>master</code> 节点挂掉，<code>Redis</code> 将不再对外提供读写操作。假设当主从复制中的 <code>master</code> 节点挂掉后，如果能够从它的 <code>slave</code> 节点中重新选举一个节点作为 <code>master</code> 节点，那么系统就可以恢复了，因此就有了 <code>Redis</code> 的哨兵（sentinel）模式。</p>`,38),p={href:"https://redis.io/docs/manual/scaling",target:"_blank",rel:"noopener noreferrer"},h=s(`<p>Redis Sentinel 还提供其他附带任务，例如监控、 通知并充当客户端的配置提供程序。</p><h4 id="功能" tabindex="-1"><a class="header-anchor" href="#功能"><span>功能</span></a></h4><ul><li><p>监控：<code>Sentinel</code> 会不断检查 <code>Redis</code> 主从实例是否正常工作；</p></li><li><p>通知：当被监控的 <code>Redis</code> 实例出问题时，能通过 API 通知系统管理员或其他程序；</p></li><li><p>自动故障转移：如果主实例没有正常工作，<code>Sentinel</code> 将启动故障恢复机制把一个从实例提升为主实例，其他的从实例将会被重新配置到新的主实例，且应用程序会得到一个更换新地址的通知。</p></li><li><p>配置提供程序：因为 <code>Sentinel</code> 保存着 <code>Redis</code> 主从的信息，所以 <code>Redis</code> 可以从 <code>Sentinel</code> 那获得所有的配置信息。</p></li></ul><h4 id="配置-1" tabindex="-1"><a class="header-anchor" href="#配置-1"><span>配置</span></a></h4><p>在指定 Redis 版本源码包中找到 <code>sentinel.conf</code> 配置文件，修改要监控的主服务地址</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span>
sentinel monitor mymaster <span class="token number">192.168</span>.208.128 <span class="token number">6379</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>告诉 Redis Sentinel 一个名为 <em>mymaster</em> 的 master， 即地址 192.168.208.128 端口 6379，仲裁为 2。</p><p><code>quorum</code> 是无法访问主节点时，需要 <code>quorum</code> 个哨兵监控到主节点下线后，哨兵们会重新投票选举 slave 节点作为 master 节点，恢复系统的读写操作，后续如果老的 主节点恢复工作，则作为从节点提供服务。</p><h4 id="运行" tabindex="-1"><a class="header-anchor" href="#运行"><span>运行</span></a></h4><p>默认情况下，哨兵会侦听 TCP 端口 26379 的连接，因此要使 Sentinels 正常工作，服务器 26379 端口必须打开才能接收来自其他 Sentinel 实例的 IP 地址的连接。 否则，哨兵无法交谈，也无法就要执行的操作达成一致，因此永远不会进行故障转移。</p><p>可使用以下两种方式运行</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 方式一</span>
redis-sentinel /path/to/sentinel.conf
<span class="token comment"># 方式二</span>
redis-server /path/to/sentinel.conf <span class="token parameter variable">--sentinel</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至少需要三个 Sentinel 实例才能进行可靠的部署。</p><p>三个 sentinel 实例应放置在不同区域不同物理服务器或虚拟机。</p>`,14);function m(u,v){const n=d("ExternalLinkIcon");return l(),t("div",null,[o,a("p",null,[e("Redis Sentinel 在不使用 "),a("a",p,[e("Redis 集群"),r(n)]),e(" 时为 Redis 提供高可用性。")]),h])}const f=i(c,[["render",m],["__file","Redis.html.vue"]]),R=JSON.parse('{"path":"/devops/redis/Redis.html","title":"Redis","lang":"zh-CN","frontmatter":{"title":"Redis","date":"2024-04-12T17:07:05.000Z","order":1,"description":"Redis 文件结构 常用命令 数据持久化 数据备份 TODO 数据迁移 AOF方式 AOF方式依赖于AOF文件，AOF文件记录了所有写命令。 将源服务器中的AOF文件复制到目标服务器 目标服务器开启AOF功能 将源服务器AOF文件数据导入目标服务器 RDB方式 使用 Redis 命令创建当前数据库备份，将在安装目录中创建 dump.rdb 文件。 创...","head":[["meta",{"property":"og:url","content":"https://dahlzb.github.io/docs/devops/redis/Redis.html"}],["meta",{"property":"og:site_name","content":"DahlZb小站"}],["meta",{"property":"og:title","content":"Redis"}],["meta",{"property":"og:description","content":"Redis 文件结构 常用命令 数据持久化 数据备份 TODO 数据迁移 AOF方式 AOF方式依赖于AOF文件，AOF文件记录了所有写命令。 将源服务器中的AOF文件复制到目标服务器 目标服务器开启AOF功能 将源服务器AOF文件数据导入目标服务器 RDB方式 使用 Redis 命令创建当前数据库备份，将在安装目录中创建 dump.rdb 文件。 创..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-22T11:57:08.000Z"}],["meta",{"property":"article:author","content":"DahlZb"}],["meta",{"property":"article:published_time","content":"2024-04-12T17:07:05.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-22T11:57:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-12T17:07:05.000Z\\",\\"dateModified\\":\\"2024-04-22T11:57:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DahlZb\\",\\"url\\":\\"https://github.com/dahlzb\\"}]}"]]},"headers":[{"level":2,"title":"Redis","slug":"redis","link":"#redis","children":[{"level":3,"title":"文件结构","slug":"文件结构","link":"#文件结构","children":[]},{"level":3,"title":"常用命令","slug":"常用命令","link":"#常用命令","children":[]},{"level":3,"title":"数据持久化","slug":"数据持久化","link":"#数据持久化","children":[]},{"level":3,"title":"主从复制","slug":"主从复制","link":"#主从复制","children":[]},{"level":3,"title":"哨兵机制","slug":"哨兵机制","link":"#哨兵机制","children":[]}]}],"git":{"createdTime":1713787028000,"updatedTime":1713787028000,"contributors":[{"name":"dahlzb","email":"1304187196@qq.com","commits":1}]},"readingTime":{"minutes":5.26,"words":1577},"filePathRelative":"devops/redis/Redis.md","localizedDate":"2024年4月12日","excerpt":"<h2>Redis</h2>\\n<h3>文件结构</h3>\\n<div class=\\"language-text\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"language-text\\"><code>redis-server        redis服务器\\nredis-cli           redis命令行客户端\\nredis-benchmark     redis性能测试工具\\nredis-check-aof     aof文件修复工具\\nredis-check-dump    rdb文件检查工具\\n</code></pre></div><h3>常用命令</h3>","autoDesc":true}');export{f as comp,R as data};
